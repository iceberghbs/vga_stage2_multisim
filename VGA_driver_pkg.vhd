---------------------------------------------------
-- Sheet: vga_driver
-- RefDes: 
-- Part Number: XC7A35T
-- Generated By: Multisim
--
-- Author: lenovo
-- Date: Monday, May 03 16:47:05, 2021
---------------------------------------------------

---------------------------------------------------
-- Use: This file contains definitions of components
-- Use with the exported top-level file
---------------------------------------------------
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.numeric_std.ALL;

package VGA_driver_pkg is

	component AND2_NI
		port (
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
	end component;

	component AND3_NI
		port (
    C : in STD_LOGIC := 'X';
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
	end component;

	component AND4_NI
		port (
    D : in STD_LOGIC := 'X';
    C : in STD_LOGIC := 'X';
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
	end component;

	component AND7_NI
		port (
    G : in STD_LOGIC := 'X';
    F : in STD_LOGIC := 'X';
    E : in STD_LOGIC := 'X';
    D : in STD_LOGIC := 'X';
    C : in STD_LOGIC := 'X';
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
	end component;

	component AND8_NI
		port (
    H : in STD_LOGIC := 'X';
    G : in STD_LOGIC := 'X';
    F : in STD_LOGIC := 'X';
    E : in STD_LOGIC := 'X';
    D : in STD_LOGIC := 'X';
    C : in STD_LOGIC := 'X';
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
	end component;

	component AUTO_IBUF
		port(
		I : in std_logic;
		O : out std_logic
	);
	end component;

	component AUTO_OBUF
		port(
		I : in std_logic;
		O : out std_logic
	);
	end component;

	component CNTR_4BIN_S_NI
		port( 
  LOAD: in STD_LOGIC;
  CLR: in STD_LOGIC;
  ENP: in STD_LOGIC; 
  ENT: in STD_LOGIC;
  CLK: in STD_LOGIC;
  A :in STD_LOGIC;
  B :in STD_LOGIC;
  C :in STD_LOGIC;
  D :in STD_LOGIC;
  RCO : out STD_LOGIC;
  QA : out STD_LOGIC;
  QB : out STD_LOGIC;
  QC : out STD_LOGIC;
  QD : out STD_LOGIC
 );
	end component;

	component CNTR_BCD_S_NI
		port( 
  LOAD: in std_logic;
  CLR: in std_logic;
  ENP: in std_logic; 
  ENT: in std_logic;
  CLK: in std_logic;
  A:in STD_LOGIC;
  B:in STD_LOGIC;
  C:in STD_LOGIC;
  D:in STD_LOGIC;
  RCO: out STD_LOGIC;
  QA: out STD_LOGIC;
  QB: out STD_LOGIC;
  QC: out STD_LOGIC;
  QD: out STD_LOGIC
 );
	end component;

	component DIGITAL_HIGH_NI
		Port ( 
  Y : out  STD_LOGIC:='1'
 );
	end component;

	component DIGITAL_LOW_NI
		Port ( 
  Y : out  STD_LOGIC:='0'
 );
	end component;

	component FF_JK_PSCLR_CO_NI
		port (
   J: in STD_LOGIC;
   K: in STD_LOGIC;
   CLK : in STD_LOGIC;  
   PR: in STD_LOGIC;
   CLR: in STD_LOGIC;
   Q : out STD_LOGIC;
   Qneg : out STD_LOGIC
);
	end component;

	component FF_T_CLR_CO_NI
		port (
    T: in STD_LOGIC;
    CLK : in STD_LOGIC;
    CLR : in STD_LOGIC;
     Q : out STD_LOGIC;
     Qneg : out STD_LOGIC
 );
	end component;

	component INV_NI
		port (
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
	end component;

	component OR2_NI
		port (
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
	end component;

end VGA_driver_pkg;
package body VGA_driver_pkg is
end VGA_driver_pkg;


library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity AND2_NI is
  port (
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
end AND2_NI;

architecture BEHAVIORAL of AND2_NI is  

begin
  Y <= A and B;
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity AND3_NI is
  port (
    C : in STD_LOGIC := 'X';
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
end AND3_NI;

architecture BEHAVIORAL of AND3_NI is  

begin
  Y <= (A and B and C);
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity AND4_NI is
  port (
    D : in STD_LOGIC := 'X';
    C : in STD_LOGIC := 'X';
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
end AND4_NI;

architecture BEHAVIORAL of AND4_NI is  

begin
  Y <= (A and B and C and D);
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity AND7_NI is
  port (
    G : in STD_LOGIC := 'X';
    F : in STD_LOGIC := 'X';
    E : in STD_LOGIC := 'X';
    D : in STD_LOGIC := 'X';
    C : in STD_LOGIC := 'X';
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
end AND7_NI;

architecture BEHAVIORAL of AND7_NI is  

begin
  Y <= (A and B and C and D and E and F and G);
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity AND8_NI is
  port (
    H : in STD_LOGIC := 'X';
    G : in STD_LOGIC := 'X';
    F : in STD_LOGIC := 'X';
    E : in STD_LOGIC := 'X';
    D : in STD_LOGIC := 'X';
    C : in STD_LOGIC := 'X';
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
end AND8_NI;

architecture BEHAVIORAL of AND8_NI is  

begin
  Y <= (A and B and C and D and E and F and G and H);
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.all;

entity AUTO_IBUF is
	port(
		I : in std_logic;
		O : out std_logic
	);end AUTO_IBUF;

architecture AUTO_IBUF_ARCH of AUTO_IBUF is

begin
 O <= I;
end AUTO_IBUF_ARCH;


library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.all;

entity AUTO_OBUF is
	port(
		I : in std_logic;
		O : out std_logic
	);end AUTO_OBUF;

architecture AUTO_OBUF_ARCH of AUTO_OBUF is

begin
 O <= I;
end AUTO_OBUF_ARCH;


library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity CNTR_4BIN_S_NI is
 port( 
  LOAD: in STD_LOGIC;
  CLR: in STD_LOGIC;
  ENP: in STD_LOGIC; 
  ENT: in STD_LOGIC;
  CLK: in STD_LOGIC;
  A :in STD_LOGIC;
  B :in STD_LOGIC;
  C :in STD_LOGIC;
  D :in STD_LOGIC;
  RCO : out STD_LOGIC;
  QA : out STD_LOGIC;
  QB : out STD_LOGIC;
  QC : out STD_LOGIC;
  QD : out STD_LOGIC
 );
end CNTR_4BIN_S_NI;

architecture BEHAVIORAL of CNTR_4BIN_S_NI is
signal Q: STD_LOGIC_VECTOR(3 downto 0);

begin
 RCO<=Q(3) and Q(2) and Q(1) and Q(0) and ENT;
 process
 begin
   wait until CLK='1';
   if CLR = '0' then Q<="0000";
     elsif LOAD='0' then Q<=D&C&B&A;
     elsif (ENP and ENT)='1' then
     Q<=Q+"0001";
  end if;
 end process;
 QD<=Q(3);
 QC<=Q(2);
 QB<=Q(1);
 QA<=Q(0);
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity CNTR_BCD_S_NI is
 port( 
  LOAD: in std_logic;
  CLR: in std_logic;
  ENP: in std_logic; 
  ENT: in std_logic;
  CLK: in std_logic;
  A:in STD_LOGIC;
  B:in STD_LOGIC;
  C:in STD_LOGIC;
  D:in STD_LOGIC;
  RCO: out STD_LOGIC;
  QA: out STD_LOGIC;
  QB: out STD_LOGIC;
  QC: out STD_LOGIC;
  QD: out STD_LOGIC
 );
end CNTR_BCD_S_NI;

architecture BEHAVIORAL of CNTR_BCD_S_NI is
signal Q: STD_LOGIC_VECTOR(3 downto 0);

begin
 process
 begin
 wait until CLK='1';
  if CLR = '0' then Q<="0000";
	             RCO<='0';
  elsif LOAD='0' then Q<=D&C&B&A;
		  RCO<='0';
  elsif (ENP and ENT)='1' then
   if Q="1000" then 
		RCO<='1';
		Q<=Q+"0001";
   elsif Q="1001" then 
		Q<="0000";
		RCO<='0';
   else
		Q<=Q+"0001";
		RCO<='0';
   end if;
  end if;
 end process;
 QD<=Q(3);
 QC<=Q(2);
 QB<=Q(1);
 QA<=Q(0);	
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity DIGITAL_HIGH_NI is
 Port ( 
  Y : out  STD_LOGIC:='1'
 );
end DIGITAL_HIGH_NI;

architecture BEHAVIORAL of DIGITAL_HIGH_NI is
begin
 Y<='1';
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity DIGITAL_LOW_NI is
 Port ( 
  Y : out  STD_LOGIC:='0'
 );
end DIGITAL_LOW_NI;

architecture BEHAVIORAL of DIGITAL_LOW_NI is
begin
 Y<='0';
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity FF_JK_PSCLR_CO_NI is
  port (
   J: in STD_LOGIC;
   K: in STD_LOGIC;
   CLK : in STD_LOGIC;  
   PR: in STD_LOGIC;
   CLR: in STD_LOGIC;
   Q : out STD_LOGIC;
   Qneg : out STD_LOGIC
);
end FF_JK_PSCLR_CO_NI;

architecture BEHAVIORAL of FF_JK_PSCLR_CO_NI is  
signal Qnot: STD_LOGIC:='0';
signal Qpos: STD_LOGIC:='1';

begin
  process (CLK,PR,CLR)
  begin
      if (PR='0' and CLR='1') then  Qpos<='1';
                                                       Qnot<='0';
          elsif (PR='1' and CLR='0') then Qpos<='0';
                                                              Qnot<='1'; 
          elsif (PR='0' and CLR='0') then Qpos<='1';
                                                               Qnot<='1';
          elsif (CLK'event and CLK='1') then
	    if (J='1' and K='1') then Qpos<=Qnot;
		                           Qnot<=Qpos;	
                    elsif (J='0' and K='1') then Qpos<='0';
		                               Qnot<='1';	
	    elsif (J='1' and K='0') then Qpos<='1';
			               Qnot<='0';							  
	    end if;
           end if;
 end process;		
 Qneg<=Qnot;
 Q<=Qpos;
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity FF_T_CLR_CO_NI is
 port (
    T: in STD_LOGIC;
    CLK : in STD_LOGIC;
    CLR : in STD_LOGIC;
     Q : out STD_LOGIC;
     Qneg : out STD_LOGIC
 );
end FF_T_CLR_CO_NI;

architecture BEHAVIORAL of FF_T_CLR_CO_NI is  
signal Qpos: STD_LOGIC:='1';
signal Qnot: STD_LOGIC:='0';

begin
 process (CLR,T,CLK)
 begin
  if CLR='0' then
	Qpos<='0';
	Qnot<='1';
  elsif (CLK'event and CLK='1') then
     if (T='1') then Qpos<=not Qpos;
	            Qnot<=not Qnot; 
     end if;
  end if;	
 end process;		
 Q<=Qpos;
 Qneg<=Qnot;
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity INV_NI is
  port (
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
end INV_NI;

architecture BEHAVIORAL of INV_NI is  

begin
  Y <= NOT(A);
end BEHAVIORAL;

library work;
use work.VGA_driver_pkg.ALL;
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity OR2_NI is
  port (
    B : in STD_LOGIC := 'X';
    A : in STD_LOGIC := 'X';
    Y : out STD_LOGIC := 'U'
  );
end OR2_NI;

architecture BEHAVIORAL of OR2_NI is  

begin
  Y <= A or B;
end BEHAVIORAL;
